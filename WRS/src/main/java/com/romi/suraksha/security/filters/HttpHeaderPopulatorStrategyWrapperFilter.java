/**
 * 
 */
package com.romi.suraksha.security.filters;

import java.io.IOException;
import java.util.Iterator;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.switchuser.SwitchUserGrantedAuthority;
import org.springframework.web.filter.GenericFilterBean;

/**
 * @author rawsthy
 * 
 */
public class HttpHeaderPopulatorStrategyWrapperFilter extends GenericFilterBean {
	private Logger logger = org.slf4j.LoggerFactory
			.getLogger(HttpHeaderPopulatorStrategyWrapperFilter.class);
	private HTTPHeaderPopulator customHeaderPopulator;

	@Override
	public void afterPropertiesSet() throws ServletException {
		super.afterPropertiesSet();
	}

	/**
	 * 
	 */
	public int getOrder() {
		return 0;
	}

	public HTTPHeaderPopulator getCustomHeaderPopulator() {
		return customHeaderPopulator;
	}

	public void setCustomHeaderPopulator(
			HTTPHeaderPopulator customHeaderPopulator) {
		this.customHeaderPopulator = customHeaderPopulator;
	}

	/**
	 * Determines if HTTP Headers need to be set. After LDAP authentication
	 * happens it creates UsernamePasswordAuthenticationToken object. However
	 * since we only use LDAP to emulate authentication process on the dev
	 * machines we are using it to populate HTTP Headers which later on picked
	 * up by WebSEALHeaderPreAuthenticatedFilter and the new Authentication
	 * object of type PreAuthenticatedAuthenticationToken is created. Once this
	 * object is registered with the Security context we don't need the headers
	 * any more, thus won't require any authentication. Another check we must
	 * make here is for SwitchUserGrantedAuthority and don't allow headers to be
	 * populated if current session is impersonating another user. The reason
	 * behind it is because SwitchUserProcesingFilter while creating a new
	 * Authentication object will create it as
	 * UsernamePasswordAuthenticationToken (the same Authentication type that is
	 * generated by LdapAuthenticationProvider), which will make this system
	 * assume that you have just been authenticated by the LDAP, thus requiring
	 * Header population. To make it simple, we don't need to re-populate HTTP
	 * headers if we are impersonating another user.
	 * 
	 * @return
	 */
	protected boolean headersRequired() {
		Authentication authentication = SecurityContextHolder.getContext()
				.getAuthentication();
		boolean switchedUser = false;
		boolean required = false;
		if (authentication != null) {
			Iterator<GrantedAuthority> authorities = (Iterator<GrantedAuthority>) authentication
					.getAuthorities().iterator();
			while (authorities.hasNext()) {
				GrantedAuthority grantedAuthority = authorities.next();
				if (grantedAuthority instanceof SwitchUserGrantedAuthority) {
					switchedUser = true;
					// exit immediately if user is impersonating
					// you could potentially return false here as we don't need
					// to do any more checking for anything
					break;
				}
			}
			required = authentication.getClass().isAssignableFrom(
					UsernamePasswordAuthenticationToken.class);
		}
		return required && !switchedUser && customHeaderPopulator != null;
	}


	public void doFilter(ServletRequest request, ServletResponse response,
			FilterChain chain) throws IOException, ServletException {
		// In the production environment WebSEALHeaderPopulator will not be
		// loaded
		// which means this code will never execute

		logger.debug(">>> Executing HttpHeaderPopulatorStrategyWrapperFilter");
		if (headersRequired()) {

			logger.debug(">>> HttpHeaderPopulatorStrategyWrapperFilter - Allowing to proceed to set headers");
			request = customHeaderPopulator.addHeaders(
					(HttpServletRequest) request,
					(HttpServletResponse) response);
			// Destroy the actual Authentication object so it could be
			// regenerated by WebSEALHeaderPreAuthenticatedFilter
			// based on HTTP headers
			// logger.debug(">>> Destroying the original Authentication: "
			// + SecurityContextHolder.getContext().getAuthentication());
			// SecurityContextHolder.getContext().setAuthentication(null);
		}
		chain.doFilter(request, response);

	}

}
